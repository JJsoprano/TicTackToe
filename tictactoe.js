// tictactoe.js

// --- DOM Element References ---
// These variables will store references to various HTML elements on the page.
// They are initialized once the HTML document is fully loaded (in DOMContentLoaded).
let body; // Reference to the <body> element, used for changing background on win/loss.
let gameboard; // The main container for the Tic-Tac-Toe cells.
let turnMessageDisplay; // Displays messages indicating whose turn it is.
let infoDisplay; // Displays general game status messages (e.g., "You are playing against the AI!").
let newGameBtn; // Button to start a new game.
let playerOCircleScoreDisplay; // Displays Player O's (Circle) score.
let playerXCrossScoreDisplay; // Displays Player X's (Cross) score.
let tiesScoreDisplay; // Displays the number of tied games.
let clearScoresBtn; // Button to clear all saved scores.
let llmCommentaryDisplay; // Displays commentary generated by the Large Language Model (LLM).
let llmLoadingIndicator; // Shows a loading spinner or message while LLM commentary is fetched.
let xWinBurst; // Placeholder for a visual effect when X wins (might be unused if fireworks are used).
let oWinEffect; // Placeholder for a visual effect when O wins (might be unused if fireworks are used).

// Buttons for selecting the game mode (single player vs. two player).
let singlePlayerBtn;
let twoPlayerBtn;


// --- Game State Variables (Client-side) ---
// These variables hold the current state of the game in memory.
let currentBoard = ["", "", "", "", "", "", "", "", ""]; // Represents the 3x3 Tic-Tac-Toe board.
// Each element is a string: "" for empty, 'circle' for O, 'x' for X.
let currentPlayer = 'circle'; // Tracks whose turn it is. 'circle' plays first by default.
let gameEnded = false;      // A boolean flag: true if the game is over (win or draw), false otherwise.
let playerOScore = 0;       // Stores the win count for Player O.
let playerXScore = 0;       // Stores the win count for Player X.
let tiesScore = 0;          // Stores the count of tied games.
let gameMode = null;        // Stores the selected game mode: 'singlePlayer' or 'twoPlayer'.

// Winning combinations for Tic-Tac-Toe.
// Each inner array contains the indices of three cells that form a winning line.
const winningConditions = [
    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows: Top, Middle, Bottom
    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns: Left, Middle, Right
    [0, 4, 8], [2, 4, 6]    // Diagonals: Top-left to Bottom-right, Top-right to Bottom-left
];

// --- Utility Functions ---

/**
 * Capitalizes the first letter of a given player string.
 *
 * This function is used to display the player names in sentence case,
 * which is more user-friendly than the all-lowercase strings used
 * internally to represent the players.
 *
 * @param {string} player - The player string (e.g., 'circle' or 'x').
 * @returns {string} The capitalized player name (e.g., 'Circle' or 'X').
 */
function capitalizePlayerName(player) {
    // Get the first character of the player string.
    const firstChar = player.charAt(0);
    // Get the rest of the string (everything after the first character).
    const restOfString = player.slice(1);
    // Return the capitalized player name by concatenating the
    // capitalized first character with the rest of the string.
    return firstChar.toUpperCase() + restOfString;
}

/**
 * Updates the main status message displayed on the game interface.
 *
 * This function is called to update the main game status message in the
 * HTML interface. It checks if the infoDisplay element exists and is
 * visible before attempting to update the message.
 *
 * @param {string} message - The message to display in the game status area.
 */
function updateGameStatus(message) {
    // Ensure the infoDisplay element exists and is visible before updating it.
    if (infoDisplay && infoDisplay.style.display !== 'none') {
        infoDisplay.textContent = message; // Set the text content of the display.
    }
}

/**
 * Updates the message indicating whose turn it is in the game.
 * This function checks if the game has ended and updates the UI accordingly.
 * @param {string} player - Represents the current player ('circle' or 'x').
 */
function updateTurnMessage(player) {
    // Ensure the turn message display element exists before attempting to update it.
    if (turnMessageDisplay) {
        // Check if the game has ended.
        if (gameEnded) {
            // Set the turn message to "Game Over!" if the game is concluded.
            turnMessageDisplay.textContent = "Game Over!";
        } else {
            // Otherwise, update the turn message to indicate the current player's turn.
            // The player's name is capitalized for a better user experience.
            turnMessageDisplay.textContent = `It's ${capitalizePlayerName(player)}'s turn!`;
        }
        // Make sure the turn message display element is visible in the UI.
        turnMessageDisplay.style.display = 'block';
    }
}

// --- Game Board Rendering ---

/**
 * Dynamically creates the 9 cell elements for the Tic-Tac-Toe board in the DOM.
 * It clears the existing content inside the gameboard element and then
 * appends the newly created cells to the gameboard container.
 */
function createBoardCells() {
    // Checks if the gameboard element has been found.
    if (!gameboard) {
        console.error("Game board element not found!"); // Log an error if it's missing.
        return; // Exit the function if no gameboard.
    }
    // Clear any existing cells or content within the gameboard.
    gameboard.innerHTML = '';

    // Loop 9 times to create each of the 9 cells.
    for (let i = 0; i < 9; i++) {
        const cell = document.createElement('div'); // Create a new <div> element for the cell.
        cell.classList.add('cell'); // Add the 'cell' CSS class for styling.
        cell.id = i; // Assign a unique ID to each cell (0-8).

        // Add an event listener to each cell for click events.
        // When clicked, `handleCellClick` is called with the cell element and `false`
        // indicating it's a human-initiated click.
        cell.addEventListener('click', () => handleCellClick(cell, false));
        // IMPORTANT: Pass false for human click
        gameboard.appendChild(cell); // Append the newly created cell to the gameboard container.
        // NOTE: The original `gameboard.appendChild(cell, false);` was incorrect.
        // `appendChild` only takes one argument. Corrected to `gameboard.appendChild(cell);`.
    }
    console.log("Board cells created."); // Debug log.
}

/**
 * Renders the current state of the `currentBoard` array onto the visual HTML board cells.
 * @param {Array<string>} boardState - The 1D array representing the board's current state.
 * It should contain only 'circle', 'x', or empty strings as values.
 */
function renderBoard(boardState) {
    currentBoard = boardState; // Update the global currentBoard to the latest state.
    const cells = gameboard.children; // Get all the div elements that are children of the gameboard.

    // Iterate through each cell and update its content and styling based on the board state.
    for (let i = 0; i < boardState.length; i++) {
        const cell = cells[i]; // Get the specific cell element.
        if (cell) {
            // Set the text content to 'O', 'X', or empty based on the boardState value.
            cell.textContent = boardState[i] === 'circle' ? 'O' : (boardState[i] === 'x' ? 'X' : '');
            // Remove any existing player-specific classes ('O' or 'X').
            cell.classList.remove('O', 'X');
            // Add the appropriate player-specific class for styling (color, text shadow).
            switch (boardState[i]) {
                case 'circle':
                    cell.classList.add('O');
                    break;
                case 'x':
                    cell.classList.add('X');
                    break;
                default: // Do nothing for empty cells.
            }
        }
    }
    console.log("Board rendered."); // Debug log.
}

// --- Game Logic ---

/**
 * Checks if a given player has achieved a winning combination on the current board.
 * The winning combinations are defined in the `winningConditions` array,
 * which contains arrays of three cell indices that represent possible winning lines.
 * @param {Array<string>} board - The current state of the game board.
 * @param {string} player - The player to check for a win ('circle' or 'x').
 * @returns {boolean} True if the player has won, false otherwise.
 */
function checkForWin(board, player) {
    // The `some()` method checks if at least one element in the `winningConditions` array
    // satisfies the provided testing function.
    return winningConditions.some(combination => {
        const [a, b, c] = combination; // Destructure the combination into three cell indices.
        // Return true if all three cells in the combination are occupied by the current player.
        // This means the player has won if all three cells in the combination have the same value (i.e., the player's mark).
        return board[a] === player && board[b] === player && board[c] === player;
    });
}

/**
 * Checks if the game board is full, indicating a potential draw.
 * The game is considered a draw when there are no empty cells left
 * on the board, and no player has won.
 * 
 * @param {Array<string>} board - The current state of the game board.
 * @returns {boolean} True if the board has no empty cells, false otherwise.
 */
function checkForDraw(board) {
    // Check if the board includes any empty strings.
    // If it does not include any, the board is full.
    return !board.includes(""); // Return true if no empty cells found.
}

/**
 * Hides all game-related UI elements and displays the mode selection buttons.
 * This function is called when a new game is started (by clicking on a mode selection button).
 */
function hideGameElements() {
    // Hide the gameboard.
    if (gameboard) gameboard.style.display = 'none';
    // Hide the new game button.
    if (newGameBtn) newGameBtn.style.display = 'none';
    // Hide the clear scores button.
    if (clearScoresBtn) clearScoresBtn.style.display = 'none';
    // Hide the scores container.
    const scoresDiv = document.querySelector('.scores');
    if (scoresDiv) scoresDiv.style.display = 'none';
    // Hide the turn message display.
    if (turnMessageDisplay) turnMessageDisplay.style.display = 'none';
    // Hide the generic information display.
    if (infoDisplay) infoDisplay.style.display = 'none';
    // Hide the commentary display.
    if (llmCommentaryDisplay) llmCommentaryDisplay.style.display = 'none';
    // Hide the loading indicator initially.
    if (llmLoadingIndicator) llmLoadingIndicator.style.display = 'none';
    // Show the game mode selection buttons.
    if (singlePlayerBtn) singlePlayerBtn.style.display = 'block';
    if (twoPlayerBtn) twoPlayerBtn.style.display = 'block';
    console.log("Game elements hidden. Mode selection visible."); // Debug log.
}

/**
 * Shows all game-related UI elements and hides the mode selection buttons.
 * This function is called when a new game is started.
 */
function showGameElements() {
    // Display various game elements by setting their display style appropriately.
    // The gameboard uses a CSS grid display.
    if (gameboard) gameboard.style.display = 'grid';
    // Display the new game button.
    if (newGameBtn) newGameBtn.style.display = 'block';
    // Display the clear scores button.
    if (clearScoresBtn) clearScoresBtn.style.display = 'block';
    // Display the scores container, which uses a flexbox display.
    const scoresDiv = document.querySelector('.scores');
    if (scoresDiv) scoresDiv.style.display = 'flex';
    // Display the turn message display.
    if (turnMessageDisplay) turnMessageDisplay.style.display = 'block';
    // Display the generic information display.
    if (infoDisplay) infoDisplay.style.display = 'block';
    // Clear any previous commentary text.
    if (llmCommentaryDisplay) llmCommentaryDisplay.textContent = '';
    // Display the commentary display.
    if (llmCommentaryDisplay) llmCommentaryDisplay.style.display = 'block';
    // Hide the loading indicator initially.
    if (llmLoadingIndicator) llmLoadingIndicator.style.display = 'none';
    // Hide the game mode selection buttons.
    if (singlePlayerBtn) singlePlayerBtn.style.display = 'none';
    if (twoPlayerBtn) twoPlayerBtn.style.display = 'none';
    console.log("Game elements shown. Mode selection hidden."); // Debug log.
}

/**
 * Initializes a new game based on the selected game mode.
 * @param {string} mode - The game mode to set ('singlePlayer' or 'twoPlayer').
 */
function startGame(mode) {
    gameMode = mode; // Set the global game mode variable.
    console.log("startGame called. gameMode set to:", gameMode); // Debug log.

    // Display the game board and controls.
    showGameElements();

    // Reset the board state, scores, and turn.
    resetGame();

    // Inform the user(s) about the game mode.
    if (gameMode === 'singlePlayer') {
        updateGameStatus("You are playing against the AI!"); // Inform the player.
        // Optional: Uncomment the following block if you want the AI to have a chance to go first.
        // If uncommented, remember to ensure 'x' is set as currentPlayer and AI move is triggered
        // before the human player makes their first move.
        // if (Math.random() < 0.5) { // 50% chance for AI to go first.
        //     currentPlayer = 'x'; // Set current player to AI (X).
        //     updateTurnMessage(currentPlayer); // Update turn message.
        //     setTimeout(() => makeAIMove(), 500); // Call AI move after a short delay.
        //     console.log("AI starting first."); // DEBUG LOG
        // }
    } else { // If mode is 'twoPlayer'.
        updateGameStatus("Two players: Human vs. Human!"); // Inform the players.
    }
}

/**
 * Implements the AI's move logic (currently a simple random move).
 * Finds all empty cells and randomly selects one to play in.
 * @summary AI chooses a random empty cell to make its move.
 */
function makeAIMove() {
    console.log("makeAIMove called. Finding empty cells..."); // Debug log.
    const emptyCells = []; // Array to store indices of empty cells.
    // Iterate through the current board to find all empty cells.
    for (let i = 0; i < currentBoard.length; i++) {
        if (currentBoard[i] === "") {
            emptyCells.push(i); // Add the index of the empty cell.
        }
    }
    console.log("Empty cells found by AI:", emptyCells); // Debug log.

    // If there are empty cells available, the AI makes a move.
    if (emptyCells.length > 0) {
        // Generate a random index to pick an empty cell.
        const randomIndex = Math.floor(Math.random() * emptyCells.length);
        const aiMoveIndex = emptyCells[randomIndex]; // Get the board index for the AI's move.
        console.log("AI selected cell index:", aiMoveIndex); // Debug log.

        // Get the actual DOM element corresponding to the selected cell ID.
        const aiCell = document.getElementById(aiMoveIndex.toString());
        if (aiCell) {
            console.log("AI simulating click on cell with ID:", aiCell.id); // Debug log.
            // Simulate a click on the chosen cell by calling `handleCellClick`.
            // Passing `true` as the second argument indicates this call is from the AI,
            // which bypasses the human-input blocking logic in `handleCellClick`.
            handleCellClick(aiCell, true); // AI "clicks" its chosen cell.
        } else {
            // Log a critical error if the DOM element for the AI's chosen cell cannot be found.
            console.error("makeAIMove: Could not find DOM element for selected AI cell ID:", aiMoveIndex);
        }
    } else {
        // This warning should ideally not happen if the game's win/draw checks are correct.
        // It means AI was called but no empty cells were available, implying the game should already be over.
        console.warn("makeAIMove: No empty cells found! This means game should have ended."); // Debug log.
    }
}

/**
 * Handles a click event on a Tic-Tac-Toe cell.
 * This function is called for both human clicks and AI-simulated clicks.
 * @param {HTMLElement} cell - The DOM element representing the cell that was clicked.
 * @param {boolean} [isAI=false] - Optional. A flag indicating if the call is from the AI (true) or a human (false).
 * Defaults to `false` for normal human clicks from event listeners.
 */
function handleCellClick(cell, isAI = false) {
    const cellId = parseInt(cell.id); // Get the numerical ID of the clicked cell from its HTML ID.
    console.log(`handleCellClick called for cell ID: ${cellId}. Current Player: ${currentPlayer}. Game Ended: ${gameEnded}. Game Mode: ${gameMode}. Is AI: ${isAI}.`); // Debug log for tracing.

    // --- Input Validation / Early Exit Conditions ---
    // 1. Prevent moves if the game has already ended.
    // 2. Prevent moves if the selected cell is already occupied (not empty).
    if (gameEnded || currentBoard[cellId] !== "") {
        console.log(`Move blocked: Game ended (${gameEnded}) or cell ${cellId} already occupied (${currentBoard[cellId]}).`); // Debug log.
        return; // Exit the function, preventing any further action for an invalid move.
    }

    // --- AI Turn Blocking Logic for Human Clicks ---
    // In single-player mode, if it's currently the AI's turn ('x') AND the click
    // did NOT originate from the AI itself (`!isAI`), then block the human input.
    // This prevents a human player from making a move while the AI is "thinking" or about to move.
    if (gameMode === 'singlePlayer' && currentPlayer === 'x' && !isAI) {
        console.log("handleCellClick: It's AI's turn, blocking human click on cell:", cellId); // Debug log.
        return; // Exit the function, blocking the human click.
    }

    // --- Apply the Move ---
    // If the move is valid (game not ended, cell not occupied, and not a blocked human click on AI's turn),
    // update the internal game board state with the current player's mark.
    currentBoard[cellId] = currentPlayer;
    renderBoard(currentBoard); // Update the visual representation of the board in the HTML.
    console.log("Board state after move:", currentBoard); // Debug log.

    // --- Check for Game Over Conditions (Win or Draw) ---

    // 1. Check for a Win:
    if (checkForWin(currentBoard, currentPlayer)) {
        gameEnded = true; // Set the game as ended.
        updateScores(currentPlayer); // Increment the winning player's score.
        updateGameStatus(`${capitalizePlayerName(currentPlayer)} won!`); // Display a win message.
        updateTurnMessage(currentPlayer); // Update the turn message to "Game Over!".
        console.log(`Game over: ${capitalizePlayerName(currentPlayer)} won!`); // Debug log.

        // Trigger visual effects based on the winning player.
        if (currentPlayer === 'x') {
            if (body) { // If body element exists.
                body.classList.add('body-x-wins'); // Add class for X win background color.
                // Remove the class after 3 seconds to reset background.
                setTimeout(() => body.classList.remove('body-x-wins'), 3000);
            }
            triggerFireworks(); // Trigger a fireworks animation.
        } else if (currentPlayer === 'circle') {
            if (body) { // If body element exists.
                body.classList.add('body-o-wins'); // Add class for O win background color.
                // Remove the class after 3 seconds to reset background.
                setTimeout(() => body.classList.remove('body-o-wins'), 3000);
            }
            triggerFireworks(); // Trigger a fireworks animation.
        }
        // Fetch a commentary from the LLM (Large Language Model) about the outcome.
        fetchLLMCommentary(`${capitalizePlayerName(currentPlayer)} won!`);
        return; // Exit the function as the game has concluded.

    // 2. Check for a Draw:
    } else if (checkForDraw(currentBoard)) {
        gameEnded = true; // Set the game as ended.
        updateScores('draw'); // Increment the ties score.
        updateGameStatus("It's a draw!"); // Display a draw message.
        updateTurnMessage(currentPlayer); // Update the turn message to "Game Over!".
        console.log("Game over: It's a draw!"); // Debug log.
        // Fetch a commentary from the LLM about the outcome.
        fetchLLMCommentary("It's a draw!");
        return; // Exit the function as the game has concluded.

    // --- Continue Game (Switch Turns) ---
    } else {
        // If no win or draw, switch the turn to the other player.
        currentPlayer = currentPlayer === 'circle' ? 'x' : 'circle';
        updateTurnMessage(currentPlayer); // Update the turn message display.
        console.log("Player switched. New current player:", currentPlayer); // Debug log.

        // --- AI Turn Trigger ---
        // If the game is in single-player mode AND has not ended AND it's now the AI's turn ('x').
        if (gameMode === 'singlePlayer' && !gameEnded && currentPlayer === 'x') {
            console.log("AI turn condition met. Disabling pointer events for 700ms."); // Debug log.
            // Temporarily disable pointer events on the game board.
            // This prevents the human player from clicking during the AI's "thinking" delay.
            if (gameboard) gameboard.style.pointerEvents = 'none';
            // Set a timeout to simulate AI "thinking" time (700 milliseconds).
            setTimeout(() => {
                console.log("AI thinking time elapsed. Calling makeAIMove."); // Debug log.
                makeAIMove(); // Execute the AI's move.
                // Re-enable pointer events on the board after the AI has attempted its move,
                // regardless of whether the AI's move ended the game.
                if (gameboard) {
                    gameboard.style.pointerEvents = 'auto';
                    console.log("Pointer events re-enabled after AI move."); // Debug log.
                }
            }, 700);
        } else if (gameMode === 'singlePlayer' && currentPlayer === 'circle') {
            // If in single-player mode and it's the human player's turn (Circle).
            console.log("It's human's turn (Circle) in single player mode. Awaiting click."); // Debug log.
        }
    }
}

/**
 * Updates the scores displayed on the UI and saves them to local storage.
 * @param {string} winner - The player who won ('circle' or 'x'), or 'draw' for a tie.
 */
function updateScores(winner) {
    // Increment the appropriate score counter based on the winner.
    // If the winner is 'circle', increment the Player O score.
    // If the winner is 'x', increment the Player X score.
    // If the winner is 'draw', increment the Ties score.
    if (winner === 'circle') {
        playerOScore++;
    } else if (winner === 'x') {
        playerXScore++;
    } else if (winner === 'draw') {
        tiesScore++;
    }
    // Update the text content of the score display elements.
    // Set the text content of the Player O score element to the current Player O score.
    // Set the text content of the Player X score element to the current Player X score.
    // Set the text content of the Ties score element to the current Ties score.
    playerOCircleScoreDisplay.textContent = playerOScore;
    playerXCrossScoreDisplay.textContent = playerXScore;
    tiesScoreDisplay.textContent = tiesScore;
    saveScores(); // Save the updated scores to local storage.
    console.log(`Scores updated. O: ${playerOScore}, X: ${playerXScore}, Ties: ${tiesScore}`); // Debug log.
}

/**
 * Loads saved scores from the browser's local storage.
 */
function loadScores() {
    console.log("Attempting to load scores from localStorage..."); // Debug log.
    const storedScores = localStorage.getItem('ticTacToeScores'); // Attempt to retrieve scores.
    if (storedScores) { // If scores were found in local storage.
        console.log("Scores found in localStorage. Attempting to parse JSON..."); // Debug log.
        try {
            const scores = JSON.parse(storedScores); // Parse the JSON string back into an object.
            console.log("Parsed scores:", scores); // Debug log.
            // Assign loaded scores, defaulting to 0 if a property is missing (for robustness).
            playerOScore = scores.playerOScore || 0;
            playerXScore = scores.playerXScore || 0;
            tiesScore = scores.tiesScore || 0;
            console.log("Loaded scores:", playerOScore, playerXScore, tiesScore); // Debug log.
            // Update the score display elements with loaded scores.
            playerOCircleScoreDisplay.textContent = playerOScore;
            playerXCrossScoreDisplay.textContent = playerXScore;
            tiesScoreDisplay.textContent = tiesScore;
            console.log("Scores loaded from localStorage. Updated display elements."); // Debug log.
        } catch (e) {
            // Catch and log any errors that occur during JSON parsing.
            console.error("Error parsing scores from localStorage:", e); // ERROR LOG.
        }
    } else {
        console.log("No scores found in localStorage. Initializing scores to 0."); // Debug log if no scores were saved previously.
    }
}

/**
 * Saves the current game scores to the browser's local storage.
 * @function saveScores
 * @description Saves the current scores for Player O, Player X, and ties to the browser's local storage.
 *              This is called whenever the scores are updated (i.e., after a game is finished).
 */
function saveScores() {
    // Create an object to store all current scores.
    const scores = {
        playerOScore, // The number of games Player O has won.
        playerXScore, // The number of games Player X has won.
        tiesScore     // The number of games that have ended in a draw.
    };
    // Convert the scores object to a JSON string and store it in local storage.
    localStorage.setItem('ticTacToeScores', JSON.stringify(scores));
    console.log("Scores saved to localStorage."); // Debug log.
}

/**
 * Resets all scores to zero, updates the UI, and clears local storage.
 * This function is called when the user clicks the "Clear Scores" button.
 */
function clearScores() {
    // --- Reset Scores ---
    // Set all player and tie scores to zero.
    playerOScore = 0;
    playerXScore = 0;
    tiesScore = 0;

    // --- Update UI Elements ---
    // Update the text content of the score display elements to reflect the reset scores.
    playerOCircleScoreDisplay.textContent = playerOScore;
    playerXCrossScoreDisplay.textContent = playerXScore;
    tiesScoreDisplay.textContent = tiesScore;

    // --- Clear Local Storage ---
    // Remove the saved scores from local storage to ensure they are not loaded again.
    localStorage.removeItem('ticTacToeScores');

    // Log the score clearing operation for debugging purposes.
    console.log("Scores cleared from display and localStorage."); // Debug log.
}

/**
 * Resets the entire game state to start a new round.
 * Clears the board, resets the current player, and updates the UI elements to reflect a new game start.
 */
function resetGame() {
    // Clear the board array to represent an empty board.
    currentBoard = ["", "", "", "", "", "", "", "", ""];

    // Reset the current player to 'circle' (O) for the start of the new game.
    currentPlayer = 'circle';

    // Reset the gameEnded flag to allow the game to proceed.
    gameEnded = false;

    // Render the empty board to the UI.
    renderBoard(currentBoard);

    // Set the initial game status message for players.
    updateGameStatus("Good luck, have fun!");

    // Display the turn message for the current player.
    updateTurnMessage(currentPlayer);

    // Clear any previous LLM commentary from the display.
    if (llmCommentaryDisplay) llmCommentaryDisplay.textContent = '';

    console.log("Game reset. Board cleared. Current Player set to 'circle'."); // Debug log.

    // Remove any win-specific background classes from the body to reset visual effects.
    if (body) {
        body.classList.remove('body-o-wins', 'body-x-wins');
    }

    // Ensure the game board is clickable after reset for player interactions.
    if (gameboard) {
        gameboard.style.pointerEvents = 'auto';
    }
}

/**
 * Triggers a fireworks animation on the screen.
 *
 * Creates a container for the fireworks sparks and appends it to the body.
 * Defines colors for the fireworks based on the current winning player.
 * Creates multiple firework explosions using the createFirework function.
 * Sets a timeout to remove the fireworks container after 2 seconds.
 */
function triggerFireworks() {
    console.log("Triggering fireworks..."); // Debug log.

    // Create a container for the fireworks sparks.
    const fireworksContainer = document.createElement('div');
    fireworksContainer.classList.add('fireworks-container'); // Add CSS class for styling.
    document.body.appendChild(fireworksContainer); // Append container to the body.

    // Define colors for the fireworks based on the current winning player.
    // Colors are red, orange, yellow for X wins and green, light green, light blue for O wins.
    const colors = currentPlayer === 'x' ? ['#ff0000', '#ff6600', '#ffcc00'] : ['#00ff00', '#00cc66', '#33ff33'];

    // Create multiple firework explosions.
    const numberOfExplosions = 10; // Number of firework explosions to create.
    for (let i = 0; i < numberOfExplosions; i++) {
        createFirework(fireworksContainer, colors); // Call function to create individual firework.
    }

    // Set a timeout to remove the fireworks container after 2 seconds.
    setTimeout(() => {
        if (document.body.contains(fireworksContainer)) { // Check if container still exists.
            document.body.removeChild(fireworksContainer); // Remove the container from the DOM.
            console.log("Fireworks container removed."); // Debug log.
        }
    }, 2000); // 2000 milliseconds = 2 seconds.
}

/**
 * Creates a single firework explosion with multiple sparks.
 * @param {HTMLElement} container - The DOM element where the sparks will be appended.
 * @param {Array<string>} colors - An array of hex color strings for the sparks.
 */
function createFirework(container, colors) {
    // Determine random starting position for the firework within the window.
    const x = Math.random() * window.innerWidth;
    const y = Math.random() * window.innerHeight;
    const numberOfSparks = 30; // Number of individual sparks in this explosion.
    // Choose a random color for this explosion's sparks from the provided color array.
    const color = colors[Math.floor(Math.random() * colors.length)];

    // Create and animate individual sparks for the firework.
    for (let i = 0; i < numberOfSparks; i++) {
        // Create a div for a single spark.
        const spark = document.createElement('div');
        spark.classList.add('firework-spark'); // Add CSS class for styling.
        spark.style.backgroundColor = color; // Set the spark's color.
        // Generate a random angle (0 to 360 degrees in radians) for the spark's velocity.
        const angle = Math.random() * Math.PI * 2;
        // Generate a random initial speed for the spark (between 2 and 7).
        const speed = Math.random() * 5 + 2;
        // Calculate the X and Y components of the velocity vector.
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        // Set the initial position of the spark to the firework's center.
        spark.style.left = `${x}px`;
        spark.style.top = `${y}px`;
        container.appendChild(spark); // Add the spark to the fireworks container.
        // Start the animation for this spark.
        animateSpark(spark, vx, vy);
    }
}

/**
 * Animates a single firework spark, simulating gravity and fading.
 * @param {HTMLElement} spark - The DOM element of the spark to animate.
 * @param {number} vx - Initial horizontal velocity.
 * @param {number} vy - Initial vertical velocity.
 */
function animateSpark(spark, vx, vy) {
    // Lifespan of the spark, controls opacity and existence.
    let life = 100;

    // Downward acceleration to simulate gravity.
    const gravity = 0.05;

    // Rate at which the spark fades.
    const fadeSpeed = 1;

    /**
     * Recursive function to update spark position and properties each animation frame.
     * This function is called repeatedly by the browser's animation frame scheduler
     * to update the spark's position, opacity, and velocity.
     * @private
     * @param {number} [timestamp] - The timestamp of the current animation frame, provided by the browser.
     */
    function update(timestamp) {
        // If the spark's life is depleted, remove it and stop animation.
        if (life <= 0) {
            if (spark.parentNode) { // Check if spark is still in the DOM.
                spark.remove(); // Remove the spark element.
            }
            return; // Stop animation for this spark.
        }

        // Get current position and calculate new opacity.
        const x = parseFloat(spark.style.left);
        const y = parseFloat(spark.style.top);
        let opacity = life / 100; // Opacity decreases as life decreases.

        // Update position based on velocity.
        spark.style.left = `${x + vx}px`;
        spark.style.top = `${y + vy}px`;
        spark.style.opacity = opacity; // Apply new opacity.

        // Apply gravity (increase downward velocity).
        vy += gravity;

        // Decrease spark's life.
        life -= fadeSpeed;

        // Request the next animation frame.
        requestAnimationFrame(update);
    }
    update(); // Start the animation loop.
}

/**
 * Fetches game commentary from a Large Language Model (LLM) based on the game outcome.
 * @param {string} outcomeDescription - A description of the game's outcome (e.g., "Player O won!", "It's a draw!").
 */
async function fetchLLMCommentary(outcomeDescription) {
    console.log("Fetching LLM commentary for:", outcomeDescription); // Debug log.
    // Show the loading indicator and clear any previous commentary text.
    if (!llmCommentaryDisplay || !llmLoadingIndicator) return;
    llmCommentaryDisplay.textContent = '';
    llmLoadingIndicator.style.display = 'block';

    await new Promise(resolve => setTimeout(resolve, 1500));
    llmCommentaryDisplay.textContent = 'Generating commentary...';
    llmLoadingIndicator.style.display = 'block';

    // Construct the prompt to send to the LLM.
    const prompt = `The tic-tac-toe game just ended. Outcome: ${outcomeDescription}. Give a very short, cheerful, and slightly witty comment about this outcome.`;

    // For security, ideally, this key would be managed on a server, not directly in client-side code.
    const apiKey = "AIzaSyDEul5h6c7Qo1I4ORfcFHbwf2KvVGNxkWY"; // Your actual Gemini API key.
    // Check if the API key is missing or still the default placeholder.
    if (!apiKey || apiKey === "YOUR_GEMINI_API_KEY_HERE") {
        console.warn("LLM API Key is missing or default. Commentary will not work."); // Warning.
        if (llmLoadingIndicator) llmLoadingIndicator.classList.add('hidden'); // Hide loading.
        if (llmCommentaryDisplay) llmCommentaryDisplay.textContent = 'API key missing for commentary.'; // Display error.
        return; // Exit if API key is invalid.
    }

    // Prepare the chat history payload for the API request.
    let chatHistory = [];
    chatHistory.push({ role: "user", parts: [{ text: prompt }] }); // Add the user prompt.
    const payload = { contents: chatHistory }; // Final payload structure.

    try {
        // Construct the API URL with the model and API key.
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        // Make the API request using fetch.
        const response = await fetch(apiUrl, {
            method: "POST", // Use POST method.
            headers: {
                "Content-Type": "application/json", // Specify JSON content type.
            },
            body: JSON.stringify(payload), // Send the payload as a JSON string.
        });

        // Check if the API response was not successful (HTTP status code 2xx).
        if (!response.ok) {
            const errorData = await response.json(); // Parse error response.
            console.error('LLM API Error:', errorData); // Log the detailed API error.
            throw new Error(`HTTP error! status: ${response.status} - ${errorData.error.message}`); // Throw an error.
        }

        const data = await response.json(); // Parse the successful response JSON.
        // Extract the commentary text from the LLM's response.
        const commentary = data.candidates[0].content.parts[0].text;
        if (llmCommentaryDisplay) llmCommentaryDisplay.textContent = commentary; // Display commentary.
        console.log("LLM commentary received:", commentary); // Debug log.

    } catch (error) {
        // Catch and log any errors that occur during the fetch operation.
        console.error('Failed to fetch LLM commentary:', error); // ERROR LOG.
        if (llmCommentaryDisplay) llmCommentaryDisplay.textContent = 'Failed to load commentary.'; // Display user-friendly error.
    } finally {
        // This block always executes, whether try or catch block was executed.
        if (llmLoadingIndicator) llmLoadingIndicator.classList.add('hidden'); // Hide loading indicator.
    }
}


// --- DOM Ready Event ---
// This code runs only after the entire HTML document has been completely loaded and parsed.
document.addEventListener("DOMContentLoaded", () => {
    // Assign DOM elements to their respective variables.
    body = document.body;
    gameboard = document.getElementById("gameboard");
    turnMessageDisplay = document.getElementById("turnMessage");
    infoDisplay = document.getElementById("info");
    newGameBtn = document.getElementById("newGameBtn");
    playerOCircleScoreDisplay = document.getElementById("playerOCircleScore");
    playerXCrossScoreDisplay = document.getElementById("playerXCrossScore");
    tiesScoreDisplay = document.getElementById("tiesScore");
    clearScoresBtn = document.getElementById("clearScoresBtn");
    llmCommentaryDisplay = document.getElementById("llmCommentaryDisplay");
    llmLoadingIndicator = document.getElementById("llmLoadingIndicator");
    xWinBurst = document.getElementById("xWinBurst");
    oWinEffect = document.getElementById("oWinEffect");

    singlePlayerBtn = document.getElementById("singlePlayerBtn");
    twoPlayerBtn = document.getElementById("twoPlayerBtn");

    // Attach event listeners to buttons.
    if (newGameBtn) {
        newGameBtn.addEventListener('click', resetGame); // Click calls resetGame.
    }
    if (clearScoresBtn) {
        clearScoresBtn.addEventListener('click', clearScores); // Click calls clearScores.
    }
    if (singlePlayerBtn) {
        // Click calls startGame in 'singlePlayer' mode.
        singlePlayerBtn.addEventListener('click', () => startGame('singlePlayer'));
    }
    if (twoPlayerBtn) {
        // Click calls startGame in 'twoPlayer' mode.
        twoPlayerBtn.addEventListener('click', () => startGame('twoPlayer'));
    }

    console.log("DOM Content Loaded. All elements assigned. Initializing game setup."); // Debug log.
    createBoardCells(); // Create the initial Tic-Tac-Toe board cells.
    createBoardCells(); // Create the initial Tic-Tac-Toe board cells.

    // Check for required DOM elements before proceeding
    if (
        body &&
        gameboard &&
        turnMessageDisplay &&
        infoDisplay &&
        newGameBtn &&
        playerOCircleScoreDisplay &&
        playerXCrossScoreDisplay &&
        tiesScoreDisplay &&
        clearScoresBtn &&
        llmCommentaryDisplay &&
        llmLoadingIndicator &&
        singlePlayerBtn &&
        twoPlayerBtn
    ) {
        loadScores();       // Load any previously saved scores.
        hideGameElements(); // Start the game with mode selection visible and game elements hidden.
    } else {
        console.error("One or more required DOM elements are missing. Please check your HTML structure.");
    }
});